---
layout: default
title: Java之CountDownLatch类使用
---
<h2>{{ page.title }}</h2>
<p>{{ page.date | date_to_string }}</p>

    上次想做爬虫，遇到问题在stackoverflow搜索的时候发现了CountDownLatch，之前没有接触过，于是去了解了一下，知道了这是一个倒计数锁。API描述：
一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用CyclicBarrier。
CountDownLatch 是一个通用同步工具，它有很多用途。将计数 1 初始化的 CountDownLatch 用作一个简单的开/关锁存器，或入口：在通过调用countDown() 的线程打开入口前，所有调用 await 的线程都一直在入口处等待。用 N 初始化的 CountDownLatch 可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成 N 次之前一直等待。
    总结一下，倒计数锁，await方法会阻塞线程直到count减到0为止。网上说count为N则必须要有N个线程的说法是错误的。API明确说了可以是N次操作，N和线程个数没有关系，亲测。
	自己猜了猜如何实现的，以为是synchronized + CAS + queue，可是它是JUC包下的，主要通过内部子类继承AQS来实现逻辑，AQS才是关键所在，看了好久的AQS源码看的都不是很清晰，但是毕竟看了那么久，写个笔记到此一游吧，以后可以接着看。
       要看懂AQS，要先了解以下知识：
       1.自旋锁
	   2.CLH queue